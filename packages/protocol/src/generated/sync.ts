// @generated by protobuf-ts 2.11.1 with parameter long_type_string
// @generated from protobuf file "sync.proto" (package "entgldb.v1", syntax proto3)
// tslint:disable
import type { BinaryWriteOptions } from "@protobuf-ts/runtime";
import type { IBinaryWriter } from "@protobuf-ts/runtime";
import { WireType } from "@protobuf-ts/runtime";
import type { BinaryReadOptions } from "@protobuf-ts/runtime";
import type { IBinaryReader } from "@protobuf-ts/runtime";
import { UnknownFieldHandler } from "@protobuf-ts/runtime";
import type { PartialMessage } from "@protobuf-ts/runtime";
import { reflectionMergePartial } from "@protobuf-ts/runtime";
import { MessageType } from "@protobuf-ts/runtime";
/**
 * Hybrid Logical Clock timestamp
 *
 * @generated from protobuf message entgldb.v1.HLCTimestamp
 */
export interface HLCTimestamp {
    /**
     * @generated from protobuf field: int64 logical_time = 1
     */
    logicalTime: string;
    /**
     * @generated from protobuf field: int32 counter = 2
     */
    counter: number;
    /**
     * @generated from protobuf field: string node_id = 3
     */
    nodeId: string;
}
/**
 * Handshake request
 *
 * @generated from protobuf message entgldb.v1.HandshakeRequest
 */
export interface HandshakeRequest {
    /**
     * @generated from protobuf field: string node_id = 1
     */
    nodeId: string;
    /**
     * @generated from protobuf field: string protocol_version = 2
     */
    protocolVersion: string; // e.g., "1.0"
    /**
     * @generated from protobuf field: string auth_token = 3
     */
    authToken: string;
    /**
     * @generated from protobuf field: repeated string supported_features = 4
     */
    supportedFeatures: string[];
}
/**
 * @generated from protobuf message entgldb.v1.HandshakeResponse
 */
export interface HandshakeResponse {
    /**
     * @generated from protobuf field: bool accepted = 1
     */
    accepted: boolean;
    /**
     * @generated from protobuf field: string server_node_id = 2
     */
    serverNodeId: string;
    /**
     * @generated from protobuf field: string protocol_version = 3
     */
    protocolVersion: string;
    /**
     * @generated from protobuf field: repeated string enabled_features = 4
     */
    enabledFeatures: string[];
    /**
     * @generated from protobuf field: string error_message = 5
     */
    errorMessage: string;
}
/**
 * Document structure
 *
 * @generated from protobuf message entgldb.v1.Document
 */
export interface Document {
    /**
     * @generated from protobuf field: string collection = 1
     */
    collection: string;
    /**
     * @generated from protobuf field: string key = 2
     */
    key: string;
    /**
     * @generated from protobuf field: bytes data = 3
     */
    data: Uint8Array; // JSON payload
    /**
     * @generated from protobuf field: entgldb.v1.HLCTimestamp timestamp = 4
     */
    timestamp?: HLCTimestamp;
    /**
     * @generated from protobuf field: bool tombstone = 5
     */
    tombstone: boolean;
}
/**
 * Oplog entry
 *
 * @generated from protobuf message entgldb.v1.OplogEntry
 */
export interface OplogEntry {
    /**
     * @generated from protobuf field: string collection = 1
     */
    collection: string;
    /**
     * @generated from protobuf field: string key = 2
     */
    key: string;
    /**
     * @generated from protobuf field: bytes data = 3
     */
    data: Uint8Array;
    /**
     * @generated from protobuf field: entgldb.v1.HLCTimestamp timestamp = 4
     */
    timestamp?: HLCTimestamp;
    /**
     * @generated from protobuf field: string operation = 5
     */
    operation: string; // "put" | "delete"
}
/**
 * Sync request (Pull changes)
 *
 * @generated from protobuf message entgldb.v1.SyncRequest
 */
export interface SyncRequest {
    /**
     * @generated from protobuf field: entgldb.v1.HLCTimestamp since = 1
     */
    since?: HLCTimestamp; // Get changes after this timestamp
    /**
     * @generated from protobuf field: repeated string collections = 2
     */
    collections: string[]; // Empty = all collections
    /**
     * @generated from protobuf field: int32 batch_size = 3
     */
    batchSize: number; // Default: 100
}
/**
 * @generated from protobuf message entgldb.v1.SyncResponse
 */
export interface SyncResponse {
    /**
     * @generated from protobuf field: repeated entgldb.v1.OplogEntry entries = 1
     */
    entries: OplogEntry[];
    /**
     * @generated from protobuf field: entgldb.v1.HLCTimestamp latest_timestamp = 2
     */
    latestTimestamp?: HLCTimestamp;
    /**
     * @generated from protobuf field: bool has_more = 3
     */
    hasMore: boolean;
}
/**
 * Push changes
 *
 * @generated from protobuf message entgldb.v1.PushRequest
 */
export interface PushRequest {
    /**
     * @generated from protobuf field: repeated entgldb.v1.OplogEntry entries = 1
     */
    entries: OplogEntry[];
}
/**
 * @generated from protobuf message entgldb.v1.PushResponse
 */
export interface PushResponse {
    /**
     * @generated from protobuf field: bool accepted = 1
     */
    accepted: boolean;
    /**
     * @generated from protobuf field: int32 applied_count = 2
     */
    appliedCount: number;
    /**
     * @generated from protobuf field: repeated string conflicts = 3
     */
    conflicts: string[]; // Keys with conflicts
}
/**
 * Clock comparison
 *
 * @generated from protobuf message entgldb.v1.GetClockRequest
 */
export interface GetClockRequest {
}
/**
 * @generated from protobuf message entgldb.v1.GetClockResponse
 */
export interface GetClockResponse {
    /**
     * @generated from protobuf field: entgldb.v1.HLCTimestamp timestamp = 1
     */
    timestamp?: HLCTimestamp;
}
/**
 * Get collections list
 *
 * @generated from protobuf message entgldb.v1.GetCollectionsRequest
 */
export interface GetCollectionsRequest {
}
/**
 * @generated from protobuf message entgldb.v1.GetCollectionsResponse
 */
export interface GetCollectionsResponse {
    /**
     * @generated from protobuf field: repeated string collections = 1
     */
    collections: string[];
}
// @generated message type with reflection information, may provide speed optimized methods
class HLCTimestamp$Type extends MessageType<HLCTimestamp> {
    constructor() {
        super("entgldb.v1.HLCTimestamp", [
            { no: 1, name: "logical_time", kind: "scalar", T: 3 /*ScalarType.INT64*/ },
            { no: 2, name: "counter", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 3, name: "node_id", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<HLCTimestamp>): HLCTimestamp {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.logicalTime = "0";
        message.counter = 0;
        message.nodeId = "";
        if (value !== undefined)
            reflectionMergePartial<HLCTimestamp>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: HLCTimestamp): HLCTimestamp {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* int64 logical_time */ 1:
                    message.logicalTime = reader.int64().toString();
                    break;
                case /* int32 counter */ 2:
                    message.counter = reader.int32();
                    break;
                case /* string node_id */ 3:
                    message.nodeId = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: HLCTimestamp, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* int64 logical_time = 1; */
        if (message.logicalTime !== "0")
            writer.tag(1, WireType.Varint).int64(message.logicalTime);
        /* int32 counter = 2; */
        if (message.counter !== 0)
            writer.tag(2, WireType.Varint).int32(message.counter);
        /* string node_id = 3; */
        if (message.nodeId !== "")
            writer.tag(3, WireType.LengthDelimited).string(message.nodeId);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message entgldb.v1.HLCTimestamp
 */
export const HLCTimestamp = new HLCTimestamp$Type();
// @generated message type with reflection information, may provide speed optimized methods
class HandshakeRequest$Type extends MessageType<HandshakeRequest> {
    constructor() {
        super("entgldb.v1.HandshakeRequest", [
            { no: 1, name: "node_id", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "protocol_version", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "auth_token", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 4, name: "supported_features", kind: "scalar", repeat: 2 /*RepeatType.UNPACKED*/, T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<HandshakeRequest>): HandshakeRequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.nodeId = "";
        message.protocolVersion = "";
        message.authToken = "";
        message.supportedFeatures = [];
        if (value !== undefined)
            reflectionMergePartial<HandshakeRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: HandshakeRequest): HandshakeRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string node_id */ 1:
                    message.nodeId = reader.string();
                    break;
                case /* string protocol_version */ 2:
                    message.protocolVersion = reader.string();
                    break;
                case /* string auth_token */ 3:
                    message.authToken = reader.string();
                    break;
                case /* repeated string supported_features */ 4:
                    message.supportedFeatures.push(reader.string());
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: HandshakeRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string node_id = 1; */
        if (message.nodeId !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.nodeId);
        /* string protocol_version = 2; */
        if (message.protocolVersion !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.protocolVersion);
        /* string auth_token = 3; */
        if (message.authToken !== "")
            writer.tag(3, WireType.LengthDelimited).string(message.authToken);
        /* repeated string supported_features = 4; */
        for (let i = 0; i < message.supportedFeatures.length; i++)
            writer.tag(4, WireType.LengthDelimited).string(message.supportedFeatures[i]);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message entgldb.v1.HandshakeRequest
 */
export const HandshakeRequest = new HandshakeRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class HandshakeResponse$Type extends MessageType<HandshakeResponse> {
    constructor() {
        super("entgldb.v1.HandshakeResponse", [
            { no: 1, name: "accepted", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
            { no: 2, name: "server_node_id", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "protocol_version", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 4, name: "enabled_features", kind: "scalar", repeat: 2 /*RepeatType.UNPACKED*/, T: 9 /*ScalarType.STRING*/ },
            { no: 5, name: "error_message", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<HandshakeResponse>): HandshakeResponse {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.accepted = false;
        message.serverNodeId = "";
        message.protocolVersion = "";
        message.enabledFeatures = [];
        message.errorMessage = "";
        if (value !== undefined)
            reflectionMergePartial<HandshakeResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: HandshakeResponse): HandshakeResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* bool accepted */ 1:
                    message.accepted = reader.bool();
                    break;
                case /* string server_node_id */ 2:
                    message.serverNodeId = reader.string();
                    break;
                case /* string protocol_version */ 3:
                    message.protocolVersion = reader.string();
                    break;
                case /* repeated string enabled_features */ 4:
                    message.enabledFeatures.push(reader.string());
                    break;
                case /* string error_message */ 5:
                    message.errorMessage = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: HandshakeResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* bool accepted = 1; */
        if (message.accepted !== false)
            writer.tag(1, WireType.Varint).bool(message.accepted);
        /* string server_node_id = 2; */
        if (message.serverNodeId !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.serverNodeId);
        /* string protocol_version = 3; */
        if (message.protocolVersion !== "")
            writer.tag(3, WireType.LengthDelimited).string(message.protocolVersion);
        /* repeated string enabled_features = 4; */
        for (let i = 0; i < message.enabledFeatures.length; i++)
            writer.tag(4, WireType.LengthDelimited).string(message.enabledFeatures[i]);
        /* string error_message = 5; */
        if (message.errorMessage !== "")
            writer.tag(5, WireType.LengthDelimited).string(message.errorMessage);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message entgldb.v1.HandshakeResponse
 */
export const HandshakeResponse = new HandshakeResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class Document$Type extends MessageType<Document> {
    constructor() {
        super("entgldb.v1.Document", [
            { no: 1, name: "collection", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "key", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "data", kind: "scalar", T: 12 /*ScalarType.BYTES*/ },
            { no: 4, name: "timestamp", kind: "message", T: () => HLCTimestamp },
            { no: 5, name: "tombstone", kind: "scalar", T: 8 /*ScalarType.BOOL*/ }
        ]);
    }
    create(value?: PartialMessage<Document>): Document {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.collection = "";
        message.key = "";
        message.data = new Uint8Array(0);
        message.tombstone = false;
        if (value !== undefined)
            reflectionMergePartial<Document>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: Document): Document {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string collection */ 1:
                    message.collection = reader.string();
                    break;
                case /* string key */ 2:
                    message.key = reader.string();
                    break;
                case /* bytes data */ 3:
                    message.data = reader.bytes();
                    break;
                case /* entgldb.v1.HLCTimestamp timestamp */ 4:
                    message.timestamp = HLCTimestamp.internalBinaryRead(reader, reader.uint32(), options, message.timestamp);
                    break;
                case /* bool tombstone */ 5:
                    message.tombstone = reader.bool();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: Document, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string collection = 1; */
        if (message.collection !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.collection);
        /* string key = 2; */
        if (message.key !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.key);
        /* bytes data = 3; */
        if (message.data.length)
            writer.tag(3, WireType.LengthDelimited).bytes(message.data);
        /* entgldb.v1.HLCTimestamp timestamp = 4; */
        if (message.timestamp)
            HLCTimestamp.internalBinaryWrite(message.timestamp, writer.tag(4, WireType.LengthDelimited).fork(), options).join();
        /* bool tombstone = 5; */
        if (message.tombstone !== false)
            writer.tag(5, WireType.Varint).bool(message.tombstone);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message entgldb.v1.Document
 */
export const Document = new Document$Type();
// @generated message type with reflection information, may provide speed optimized methods
class OplogEntry$Type extends MessageType<OplogEntry> {
    constructor() {
        super("entgldb.v1.OplogEntry", [
            { no: 1, name: "collection", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "key", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "data", kind: "scalar", T: 12 /*ScalarType.BYTES*/ },
            { no: 4, name: "timestamp", kind: "message", T: () => HLCTimestamp },
            { no: 5, name: "operation", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<OplogEntry>): OplogEntry {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.collection = "";
        message.key = "";
        message.data = new Uint8Array(0);
        message.operation = "";
        if (value !== undefined)
            reflectionMergePartial<OplogEntry>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: OplogEntry): OplogEntry {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string collection */ 1:
                    message.collection = reader.string();
                    break;
                case /* string key */ 2:
                    message.key = reader.string();
                    break;
                case /* bytes data */ 3:
                    message.data = reader.bytes();
                    break;
                case /* entgldb.v1.HLCTimestamp timestamp */ 4:
                    message.timestamp = HLCTimestamp.internalBinaryRead(reader, reader.uint32(), options, message.timestamp);
                    break;
                case /* string operation */ 5:
                    message.operation = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: OplogEntry, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string collection = 1; */
        if (message.collection !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.collection);
        /* string key = 2; */
        if (message.key !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.key);
        /* bytes data = 3; */
        if (message.data.length)
            writer.tag(3, WireType.LengthDelimited).bytes(message.data);
        /* entgldb.v1.HLCTimestamp timestamp = 4; */
        if (message.timestamp)
            HLCTimestamp.internalBinaryWrite(message.timestamp, writer.tag(4, WireType.LengthDelimited).fork(), options).join();
        /* string operation = 5; */
        if (message.operation !== "")
            writer.tag(5, WireType.LengthDelimited).string(message.operation);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message entgldb.v1.OplogEntry
 */
export const OplogEntry = new OplogEntry$Type();
// @generated message type with reflection information, may provide speed optimized methods
class SyncRequest$Type extends MessageType<SyncRequest> {
    constructor() {
        super("entgldb.v1.SyncRequest", [
            { no: 1, name: "since", kind: "message", T: () => HLCTimestamp },
            { no: 2, name: "collections", kind: "scalar", repeat: 2 /*RepeatType.UNPACKED*/, T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "batch_size", kind: "scalar", T: 5 /*ScalarType.INT32*/ }
        ]);
    }
    create(value?: PartialMessage<SyncRequest>): SyncRequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.collections = [];
        message.batchSize = 0;
        if (value !== undefined)
            reflectionMergePartial<SyncRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: SyncRequest): SyncRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* entgldb.v1.HLCTimestamp since */ 1:
                    message.since = HLCTimestamp.internalBinaryRead(reader, reader.uint32(), options, message.since);
                    break;
                case /* repeated string collections */ 2:
                    message.collections.push(reader.string());
                    break;
                case /* int32 batch_size */ 3:
                    message.batchSize = reader.int32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: SyncRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* entgldb.v1.HLCTimestamp since = 1; */
        if (message.since)
            HLCTimestamp.internalBinaryWrite(message.since, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* repeated string collections = 2; */
        for (let i = 0; i < message.collections.length; i++)
            writer.tag(2, WireType.LengthDelimited).string(message.collections[i]);
        /* int32 batch_size = 3; */
        if (message.batchSize !== 0)
            writer.tag(3, WireType.Varint).int32(message.batchSize);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message entgldb.v1.SyncRequest
 */
export const SyncRequest = new SyncRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class SyncResponse$Type extends MessageType<SyncResponse> {
    constructor() {
        super("entgldb.v1.SyncResponse", [
            { no: 1, name: "entries", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => OplogEntry },
            { no: 2, name: "latest_timestamp", kind: "message", T: () => HLCTimestamp },
            { no: 3, name: "has_more", kind: "scalar", T: 8 /*ScalarType.BOOL*/ }
        ]);
    }
    create(value?: PartialMessage<SyncResponse>): SyncResponse {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.entries = [];
        message.hasMore = false;
        if (value !== undefined)
            reflectionMergePartial<SyncResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: SyncResponse): SyncResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated entgldb.v1.OplogEntry entries */ 1:
                    message.entries.push(OplogEntry.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* entgldb.v1.HLCTimestamp latest_timestamp */ 2:
                    message.latestTimestamp = HLCTimestamp.internalBinaryRead(reader, reader.uint32(), options, message.latestTimestamp);
                    break;
                case /* bool has_more */ 3:
                    message.hasMore = reader.bool();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: SyncResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* repeated entgldb.v1.OplogEntry entries = 1; */
        for (let i = 0; i < message.entries.length; i++)
            OplogEntry.internalBinaryWrite(message.entries[i], writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* entgldb.v1.HLCTimestamp latest_timestamp = 2; */
        if (message.latestTimestamp)
            HLCTimestamp.internalBinaryWrite(message.latestTimestamp, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        /* bool has_more = 3; */
        if (message.hasMore !== false)
            writer.tag(3, WireType.Varint).bool(message.hasMore);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message entgldb.v1.SyncResponse
 */
export const SyncResponse = new SyncResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class PushRequest$Type extends MessageType<PushRequest> {
    constructor() {
        super("entgldb.v1.PushRequest", [
            { no: 1, name: "entries", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => OplogEntry }
        ]);
    }
    create(value?: PartialMessage<PushRequest>): PushRequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.entries = [];
        if (value !== undefined)
            reflectionMergePartial<PushRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: PushRequest): PushRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated entgldb.v1.OplogEntry entries */ 1:
                    message.entries.push(OplogEntry.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: PushRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* repeated entgldb.v1.OplogEntry entries = 1; */
        for (let i = 0; i < message.entries.length; i++)
            OplogEntry.internalBinaryWrite(message.entries[i], writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message entgldb.v1.PushRequest
 */
export const PushRequest = new PushRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class PushResponse$Type extends MessageType<PushResponse> {
    constructor() {
        super("entgldb.v1.PushResponse", [
            { no: 1, name: "accepted", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
            { no: 2, name: "applied_count", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 3, name: "conflicts", kind: "scalar", repeat: 2 /*RepeatType.UNPACKED*/, T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<PushResponse>): PushResponse {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.accepted = false;
        message.appliedCount = 0;
        message.conflicts = [];
        if (value !== undefined)
            reflectionMergePartial<PushResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: PushResponse): PushResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* bool accepted */ 1:
                    message.accepted = reader.bool();
                    break;
                case /* int32 applied_count */ 2:
                    message.appliedCount = reader.int32();
                    break;
                case /* repeated string conflicts */ 3:
                    message.conflicts.push(reader.string());
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: PushResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* bool accepted = 1; */
        if (message.accepted !== false)
            writer.tag(1, WireType.Varint).bool(message.accepted);
        /* int32 applied_count = 2; */
        if (message.appliedCount !== 0)
            writer.tag(2, WireType.Varint).int32(message.appliedCount);
        /* repeated string conflicts = 3; */
        for (let i = 0; i < message.conflicts.length; i++)
            writer.tag(3, WireType.LengthDelimited).string(message.conflicts[i]);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message entgldb.v1.PushResponse
 */
export const PushResponse = new PushResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class GetClockRequest$Type extends MessageType<GetClockRequest> {
    constructor() {
        super("entgldb.v1.GetClockRequest", []);
    }
    create(value?: PartialMessage<GetClockRequest>): GetClockRequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<GetClockRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: GetClockRequest): GetClockRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: GetClockRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message entgldb.v1.GetClockRequest
 */
export const GetClockRequest = new GetClockRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class GetClockResponse$Type extends MessageType<GetClockResponse> {
    constructor() {
        super("entgldb.v1.GetClockResponse", [
            { no: 1, name: "timestamp", kind: "message", T: () => HLCTimestamp }
        ]);
    }
    create(value?: PartialMessage<GetClockResponse>): GetClockResponse {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<GetClockResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: GetClockResponse): GetClockResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* entgldb.v1.HLCTimestamp timestamp */ 1:
                    message.timestamp = HLCTimestamp.internalBinaryRead(reader, reader.uint32(), options, message.timestamp);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: GetClockResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* entgldb.v1.HLCTimestamp timestamp = 1; */
        if (message.timestamp)
            HLCTimestamp.internalBinaryWrite(message.timestamp, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message entgldb.v1.GetClockResponse
 */
export const GetClockResponse = new GetClockResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class GetCollectionsRequest$Type extends MessageType<GetCollectionsRequest> {
    constructor() {
        super("entgldb.v1.GetCollectionsRequest", []);
    }
    create(value?: PartialMessage<GetCollectionsRequest>): GetCollectionsRequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<GetCollectionsRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: GetCollectionsRequest): GetCollectionsRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: GetCollectionsRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message entgldb.v1.GetCollectionsRequest
 */
export const GetCollectionsRequest = new GetCollectionsRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class GetCollectionsResponse$Type extends MessageType<GetCollectionsResponse> {
    constructor() {
        super("entgldb.v1.GetCollectionsResponse", [
            { no: 1, name: "collections", kind: "scalar", repeat: 2 /*RepeatType.UNPACKED*/, T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<GetCollectionsResponse>): GetCollectionsResponse {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.collections = [];
        if (value !== undefined)
            reflectionMergePartial<GetCollectionsResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: GetCollectionsResponse): GetCollectionsResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated string collections */ 1:
                    message.collections.push(reader.string());
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: GetCollectionsResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* repeated string collections = 1; */
        for (let i = 0; i < message.collections.length; i++)
            writer.tag(1, WireType.LengthDelimited).string(message.collections[i]);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message entgldb.v1.GetCollectionsResponse
 */
export const GetCollectionsResponse = new GetCollectionsResponse$Type();
