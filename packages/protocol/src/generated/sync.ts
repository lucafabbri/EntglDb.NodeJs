// @generated by protobuf-ts 2.11.1 with parameter long_type_string
// @generated from protobuf file "sync.proto" (package "EntglDb.Network.Proto", syntax proto3)
// tslint:disable
import type { BinaryWriteOptions } from "@protobuf-ts/runtime";
import type { IBinaryWriter } from "@protobuf-ts/runtime";
import { WireType } from "@protobuf-ts/runtime";
import type { BinaryReadOptions } from "@protobuf-ts/runtime";
import type { IBinaryReader } from "@protobuf-ts/runtime";
import { UnknownFieldHandler } from "@protobuf-ts/runtime";
import type { PartialMessage } from "@protobuf-ts/runtime";
import { reflectionMergePartial } from "@protobuf-ts/runtime";
import { MessageType as MessageType$ } from "@protobuf-ts/runtime";
/**
 * @generated from protobuf message EntglDb.Network.Proto.HandshakeRequest
 */
export interface HandshakeRequest {
    /**
     * @generated from protobuf field: string node_id = 1
     */
    nodeId: string;
    /**
     * @generated from protobuf field: string auth_token = 2
     */
    authToken: string;
    /**
     * @generated from protobuf field: repeated string supported_compression = 3
     */
    supportedCompression: string[];
}
/**
 * @generated from protobuf message EntglDb.Network.Proto.HandshakeResponse
 */
export interface HandshakeResponse {
    /**
     * @generated from protobuf field: string node_id = 1
     */
    nodeId: string;
    /**
     * @generated from protobuf field: bool accepted = 2
     */
    accepted: boolean;
    /**
     * @generated from protobuf field: string selected_compression = 3
     */
    selectedCompression: string;
}
/**
 * @generated from protobuf message EntglDb.Network.Proto.GetClockRequest
 */
export interface GetClockRequest {
}
/**
 * @generated from protobuf message EntglDb.Network.Proto.ClockResponse
 */
export interface ClockResponse {
    /**
     * @generated from protobuf field: int64 hlc_wall = 1
     */
    hlcWall: string;
    /**
     * @generated from protobuf field: int32 hlc_logic = 2
     */
    hlcLogic: number;
    /**
     * @generated from protobuf field: string hlc_node = 3
     */
    hlcNode: string;
}
/**
 * @generated from protobuf message EntglDb.Network.Proto.PullChangesRequest
 */
export interface PullChangesRequest {
    /**
     * @generated from protobuf field: int64 since_wall = 1
     */
    sinceWall: string;
    /**
     * @generated from protobuf field: int32 since_logic = 2
     */
    sinceLogic: number;
    /**
     * @generated from protobuf field: string since_node = 3
     */
    sinceNode: string;
}
/**
 * @generated from protobuf message EntglDb.Network.Proto.ChangeSetResponse
 */
export interface ChangeSetResponse {
    /**
     * @generated from protobuf field: repeated EntglDb.Network.Proto.ProtoOplogEntry entries = 1
     */
    entries: ProtoOplogEntry[];
}
/**
 * @generated from protobuf message EntglDb.Network.Proto.PushChangesRequest
 */
export interface PushChangesRequest {
    /**
     * @generated from protobuf field: repeated EntglDb.Network.Proto.ProtoOplogEntry entries = 1
     */
    entries: ProtoOplogEntry[];
}
/**
 * @generated from protobuf message EntglDb.Network.Proto.AckResponse
 */
export interface AckResponse {
    /**
     * @generated from protobuf field: bool success = 1
     */
    success: boolean;
}
/**
 * @generated from protobuf message EntglDb.Network.Proto.ProtoOplogEntry
 */
export interface ProtoOplogEntry {
    /**
     * @generated from protobuf field: string collection = 1
     */
    collection: string;
    /**
     * @generated from protobuf field: string key = 2
     */
    key: string;
    /**
     * @generated from protobuf field: string operation = 3
     */
    operation: string; // "Put" or "Delete"
    /**
     * @generated from protobuf field: string json_data = 4
     */
    jsonData: string;
    /**
     * @generated from protobuf field: int64 hlc_wall = 5
     */
    hlcWall: string;
    /**
     * @generated from protobuf field: int32 hlc_logic = 6
     */
    hlcLogic: number;
    /**
     * @generated from protobuf field: string hlc_node = 7
     */
    hlcNode: string;
}
/**
 * @generated from protobuf message EntglDb.Network.Proto.SecureEnvelope
 */
export interface SecureEnvelope {
    /**
     * @generated from protobuf field: bytes ciphertext = 1
     */
    ciphertext: Uint8Array; // Encrypted payload
    /**
     * @generated from protobuf field: bytes nonce = 2
     */
    nonce: Uint8Array; // IV or Nonce
    /**
     * @generated from protobuf field: bytes auth_tag = 3
     */
    authTag: Uint8Array; // HMAC or Auth Tag if using AEAD (optional if concatenated)
}
/**
 * Enum for wire framing (1 byte)
 *
 * @generated from protobuf enum EntglDb.Network.Proto.MessageType
 */
export enum MessageType {
    /**
     * @generated from protobuf enum value: Unknown = 0;
     */
    Unknown = 0,
    /**
     * @generated from protobuf enum value: HandshakeReq = 1;
     */
    HandshakeReq = 1,
    /**
     * @generated from protobuf enum value: HandshakeRes = 2;
     */
    HandshakeRes = 2,
    /**
     * @generated from protobuf enum value: GetClockReq = 3;
     */
    GetClockReq = 3,
    /**
     * @generated from protobuf enum value: ClockRes = 4;
     */
    ClockRes = 4,
    /**
     * @generated from protobuf enum value: PullChangesReq = 5;
     */
    PullChangesReq = 5,
    /**
     * @generated from protobuf enum value: ChangeSetRes = 6;
     */
    ChangeSetRes = 6,
    /**
     * @generated from protobuf enum value: PushChangesReq = 7;
     */
    PushChangesReq = 7,
    /**
     * @generated from protobuf enum value: AckRes = 8;
     */
    AckRes = 8,
    /**
     * @generated from protobuf enum value: SecureEnv = 9;
     */
    SecureEnv = 9
}
// @generated message type with reflection information, may provide speed optimized methods
class HandshakeRequest$Type extends MessageType$<HandshakeRequest> {
    constructor() {
        super("EntglDb.Network.Proto.HandshakeRequest", [
            { no: 1, name: "node_id", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "auth_token", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "supported_compression", kind: "scalar", repeat: 2 /*RepeatType.UNPACKED*/, T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<HandshakeRequest>): HandshakeRequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.nodeId = "";
        message.authToken = "";
        message.supportedCompression = [];
        if (value !== undefined)
            reflectionMergePartial<HandshakeRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: HandshakeRequest): HandshakeRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string node_id */ 1:
                    message.nodeId = reader.string();
                    break;
                case /* string auth_token */ 2:
                    message.authToken = reader.string();
                    break;
                case /* repeated string supported_compression */ 3:
                    message.supportedCompression.push(reader.string());
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: HandshakeRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string node_id = 1; */
        if (message.nodeId !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.nodeId);
        /* string auth_token = 2; */
        if (message.authToken !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.authToken);
        /* repeated string supported_compression = 3; */
        for (let i = 0; i < message.supportedCompression.length; i++)
            writer.tag(3, WireType.LengthDelimited).string(message.supportedCompression[i]);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message EntglDb.Network.Proto.HandshakeRequest
 */
export const HandshakeRequest = new HandshakeRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class HandshakeResponse$Type extends MessageType$<HandshakeResponse> {
    constructor() {
        super("EntglDb.Network.Proto.HandshakeResponse", [
            { no: 1, name: "node_id", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "accepted", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
            { no: 3, name: "selected_compression", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<HandshakeResponse>): HandshakeResponse {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.nodeId = "";
        message.accepted = false;
        message.selectedCompression = "";
        if (value !== undefined)
            reflectionMergePartial<HandshakeResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: HandshakeResponse): HandshakeResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string node_id */ 1:
                    message.nodeId = reader.string();
                    break;
                case /* bool accepted */ 2:
                    message.accepted = reader.bool();
                    break;
                case /* string selected_compression */ 3:
                    message.selectedCompression = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: HandshakeResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string node_id = 1; */
        if (message.nodeId !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.nodeId);
        /* bool accepted = 2; */
        if (message.accepted !== false)
            writer.tag(2, WireType.Varint).bool(message.accepted);
        /* string selected_compression = 3; */
        if (message.selectedCompression !== "")
            writer.tag(3, WireType.LengthDelimited).string(message.selectedCompression);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message EntglDb.Network.Proto.HandshakeResponse
 */
export const HandshakeResponse = new HandshakeResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class GetClockRequest$Type extends MessageType$<GetClockRequest> {
    constructor() {
        super("EntglDb.Network.Proto.GetClockRequest", []);
    }
    create(value?: PartialMessage<GetClockRequest>): GetClockRequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<GetClockRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: GetClockRequest): GetClockRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: GetClockRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message EntglDb.Network.Proto.GetClockRequest
 */
export const GetClockRequest = new GetClockRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ClockResponse$Type extends MessageType$<ClockResponse> {
    constructor() {
        super("EntglDb.Network.Proto.ClockResponse", [
            { no: 1, name: "hlc_wall", kind: "scalar", T: 3 /*ScalarType.INT64*/ },
            { no: 2, name: "hlc_logic", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 3, name: "hlc_node", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<ClockResponse>): ClockResponse {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.hlcWall = "0";
        message.hlcLogic = 0;
        message.hlcNode = "";
        if (value !== undefined)
            reflectionMergePartial<ClockResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: ClockResponse): ClockResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* int64 hlc_wall */ 1:
                    message.hlcWall = reader.int64().toString();
                    break;
                case /* int32 hlc_logic */ 2:
                    message.hlcLogic = reader.int32();
                    break;
                case /* string hlc_node */ 3:
                    message.hlcNode = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: ClockResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* int64 hlc_wall = 1; */
        if (message.hlcWall !== "0")
            writer.tag(1, WireType.Varint).int64(message.hlcWall);
        /* int32 hlc_logic = 2; */
        if (message.hlcLogic !== 0)
            writer.tag(2, WireType.Varint).int32(message.hlcLogic);
        /* string hlc_node = 3; */
        if (message.hlcNode !== "")
            writer.tag(3, WireType.LengthDelimited).string(message.hlcNode);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message EntglDb.Network.Proto.ClockResponse
 */
export const ClockResponse = new ClockResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class PullChangesRequest$Type extends MessageType$<PullChangesRequest> {
    constructor() {
        super("EntglDb.Network.Proto.PullChangesRequest", [
            { no: 1, name: "since_wall", kind: "scalar", T: 3 /*ScalarType.INT64*/ },
            { no: 2, name: "since_logic", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 3, name: "since_node", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<PullChangesRequest>): PullChangesRequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.sinceWall = "0";
        message.sinceLogic = 0;
        message.sinceNode = "";
        if (value !== undefined)
            reflectionMergePartial<PullChangesRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: PullChangesRequest): PullChangesRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* int64 since_wall */ 1:
                    message.sinceWall = reader.int64().toString();
                    break;
                case /* int32 since_logic */ 2:
                    message.sinceLogic = reader.int32();
                    break;
                case /* string since_node */ 3:
                    message.sinceNode = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: PullChangesRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* int64 since_wall = 1; */
        if (message.sinceWall !== "0")
            writer.tag(1, WireType.Varint).int64(message.sinceWall);
        /* int32 since_logic = 2; */
        if (message.sinceLogic !== 0)
            writer.tag(2, WireType.Varint).int32(message.sinceLogic);
        /* string since_node = 3; */
        if (message.sinceNode !== "")
            writer.tag(3, WireType.LengthDelimited).string(message.sinceNode);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message EntglDb.Network.Proto.PullChangesRequest
 */
export const PullChangesRequest = new PullChangesRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ChangeSetResponse$Type extends MessageType$<ChangeSetResponse> {
    constructor() {
        super("EntglDb.Network.Proto.ChangeSetResponse", [
            { no: 1, name: "entries", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => ProtoOplogEntry }
        ]);
    }
    create(value?: PartialMessage<ChangeSetResponse>): ChangeSetResponse {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.entries = [];
        if (value !== undefined)
            reflectionMergePartial<ChangeSetResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: ChangeSetResponse): ChangeSetResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated EntglDb.Network.Proto.ProtoOplogEntry entries */ 1:
                    message.entries.push(ProtoOplogEntry.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: ChangeSetResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* repeated EntglDb.Network.Proto.ProtoOplogEntry entries = 1; */
        for (let i = 0; i < message.entries.length; i++)
            ProtoOplogEntry.internalBinaryWrite(message.entries[i], writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message EntglDb.Network.Proto.ChangeSetResponse
 */
export const ChangeSetResponse = new ChangeSetResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class PushChangesRequest$Type extends MessageType$<PushChangesRequest> {
    constructor() {
        super("EntglDb.Network.Proto.PushChangesRequest", [
            { no: 1, name: "entries", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => ProtoOplogEntry }
        ]);
    }
    create(value?: PartialMessage<PushChangesRequest>): PushChangesRequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.entries = [];
        if (value !== undefined)
            reflectionMergePartial<PushChangesRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: PushChangesRequest): PushChangesRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated EntglDb.Network.Proto.ProtoOplogEntry entries */ 1:
                    message.entries.push(ProtoOplogEntry.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: PushChangesRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* repeated EntglDb.Network.Proto.ProtoOplogEntry entries = 1; */
        for (let i = 0; i < message.entries.length; i++)
            ProtoOplogEntry.internalBinaryWrite(message.entries[i], writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message EntglDb.Network.Proto.PushChangesRequest
 */
export const PushChangesRequest = new PushChangesRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class AckResponse$Type extends MessageType$<AckResponse> {
    constructor() {
        super("EntglDb.Network.Proto.AckResponse", [
            { no: 1, name: "success", kind: "scalar", T: 8 /*ScalarType.BOOL*/ }
        ]);
    }
    create(value?: PartialMessage<AckResponse>): AckResponse {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.success = false;
        if (value !== undefined)
            reflectionMergePartial<AckResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: AckResponse): AckResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* bool success */ 1:
                    message.success = reader.bool();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: AckResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* bool success = 1; */
        if (message.success !== false)
            writer.tag(1, WireType.Varint).bool(message.success);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message EntglDb.Network.Proto.AckResponse
 */
export const AckResponse = new AckResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ProtoOplogEntry$Type extends MessageType$<ProtoOplogEntry> {
    constructor() {
        super("EntglDb.Network.Proto.ProtoOplogEntry", [
            { no: 1, name: "collection", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "key", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "operation", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 4, name: "json_data", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 5, name: "hlc_wall", kind: "scalar", T: 3 /*ScalarType.INT64*/ },
            { no: 6, name: "hlc_logic", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 7, name: "hlc_node", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<ProtoOplogEntry>): ProtoOplogEntry {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.collection = "";
        message.key = "";
        message.operation = "";
        message.jsonData = "";
        message.hlcWall = "0";
        message.hlcLogic = 0;
        message.hlcNode = "";
        if (value !== undefined)
            reflectionMergePartial<ProtoOplogEntry>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: ProtoOplogEntry): ProtoOplogEntry {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string collection */ 1:
                    message.collection = reader.string();
                    break;
                case /* string key */ 2:
                    message.key = reader.string();
                    break;
                case /* string operation */ 3:
                    message.operation = reader.string();
                    break;
                case /* string json_data */ 4:
                    message.jsonData = reader.string();
                    break;
                case /* int64 hlc_wall */ 5:
                    message.hlcWall = reader.int64().toString();
                    break;
                case /* int32 hlc_logic */ 6:
                    message.hlcLogic = reader.int32();
                    break;
                case /* string hlc_node */ 7:
                    message.hlcNode = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: ProtoOplogEntry, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string collection = 1; */
        if (message.collection !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.collection);
        /* string key = 2; */
        if (message.key !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.key);
        /* string operation = 3; */
        if (message.operation !== "")
            writer.tag(3, WireType.LengthDelimited).string(message.operation);
        /* string json_data = 4; */
        if (message.jsonData !== "")
            writer.tag(4, WireType.LengthDelimited).string(message.jsonData);
        /* int64 hlc_wall = 5; */
        if (message.hlcWall !== "0")
            writer.tag(5, WireType.Varint).int64(message.hlcWall);
        /* int32 hlc_logic = 6; */
        if (message.hlcLogic !== 0)
            writer.tag(6, WireType.Varint).int32(message.hlcLogic);
        /* string hlc_node = 7; */
        if (message.hlcNode !== "")
            writer.tag(7, WireType.LengthDelimited).string(message.hlcNode);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message EntglDb.Network.Proto.ProtoOplogEntry
 */
export const ProtoOplogEntry = new ProtoOplogEntry$Type();
// @generated message type with reflection information, may provide speed optimized methods
class SecureEnvelope$Type extends MessageType$<SecureEnvelope> {
    constructor() {
        super("EntglDb.Network.Proto.SecureEnvelope", [
            { no: 1, name: "ciphertext", kind: "scalar", T: 12 /*ScalarType.BYTES*/ },
            { no: 2, name: "nonce", kind: "scalar", T: 12 /*ScalarType.BYTES*/ },
            { no: 3, name: "auth_tag", kind: "scalar", T: 12 /*ScalarType.BYTES*/ }
        ]);
    }
    create(value?: PartialMessage<SecureEnvelope>): SecureEnvelope {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.ciphertext = new Uint8Array(0);
        message.nonce = new Uint8Array(0);
        message.authTag = new Uint8Array(0);
        if (value !== undefined)
            reflectionMergePartial<SecureEnvelope>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: SecureEnvelope): SecureEnvelope {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* bytes ciphertext */ 1:
                    message.ciphertext = reader.bytes();
                    break;
                case /* bytes nonce */ 2:
                    message.nonce = reader.bytes();
                    break;
                case /* bytes auth_tag */ 3:
                    message.authTag = reader.bytes();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: SecureEnvelope, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* bytes ciphertext = 1; */
        if (message.ciphertext.length)
            writer.tag(1, WireType.LengthDelimited).bytes(message.ciphertext);
        /* bytes nonce = 2; */
        if (message.nonce.length)
            writer.tag(2, WireType.LengthDelimited).bytes(message.nonce);
        /* bytes auth_tag = 3; */
        if (message.authTag.length)
            writer.tag(3, WireType.LengthDelimited).bytes(message.authTag);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message EntglDb.Network.Proto.SecureEnvelope
 */
export const SecureEnvelope = new SecureEnvelope$Type();
